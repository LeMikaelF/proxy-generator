package generator

import (
	"errors"
	"fmt"
	"github.com/LeMikaelF/proxy-generator/generator/internal/flags"
	"os"
	"testing"
)

type mockFileHandler struct {
	GetwdFunc     func() (string, error)
	ReadFileFunc  func(filename string) ([]byte, error) // Add ReadFileFunc
	WriteFileFunc func(filename string, data []byte, perm os.FileMode) error
	GlobFunc      func(pattern string) ([]string, error)
	data          map[string][]byte
}

func (m *mockFileHandler) readFile(filename string) ([]byte, error) {
	data, ok := m.data[filename]
	if !ok {
		return nil, errors.New("file not found")
	}
	return data, nil
}

func (m *mockFileHandler) glob(pattern string) ([]string, error) {
	if m.GlobFunc != nil {
		return m.GlobFunc(pattern)
	}
	filenames := make([]string, 0, len(m.data))
	for filename := range m.data {
		filenames = append(filenames, filename)
	}
	return filenames, nil
}
func (m *mockFileHandler) getwd() (string, error) {
	if m.GetwdFunc != nil {
		return m.GetwdFunc()
	}
	return ".", nil
}

func (m *mockFileHandler) writeFile(filename string, data []byte, perm os.FileMode) error {
	m.data[filename] = data
	return nil
}

func TestGenerator_New(t *testing.T) {
	t.Run("successful generator creation", func(t *testing.T) {
		mockFileHandler := &mockFileHandler{
			GetwdFunc: func() (string, error) {
				return "/working/dir", nil
			},
		}

		g, err := new(mockFileHandler, newMockFlags())
		if err != nil {
			t.Fatalf("Expected no error, %v", err)
		}

		if g.workingDir != "/working/dir" {
			t.Errorf("Expected working dir to be '/working/dir', got '%s'", g.workingDir)
		}
	})

	t.Run("error when getting working directory", func(t *testing.T) {
		mockFileHandler := &mockFileHandler{
			GetwdFunc: func() (string, error) {
				return "", errors.New("getwd error")
			},
		}

		_, err := new(mockFileHandler, newMockFlags())
		if err == nil {
			t.Fatal("Expected an error, but got none")
		}

		expectedErrMsg := "error getting current working directory: getwd error"
		if err.Error() != expectedErrMsg {
			t.Errorf("Expected error message '%s', got '%s'", expectedErrMsg, err.Error())
		}
	})
}

func newMockFlags() *flags.ParsedFlags {
	return &flags.ParsedFlags{
		PackageName:        "mypackage",
		TypeName:           "MyType",
		PassthroughMethods: map[string]bool{},
	}
}

func TestGenerator_Run(t *testing.T) {
	testCases := []struct {
		name           string
		input          string
		flags          *flags.ParsedFlags
		expectedOutput string
		expectedError  error
	}{
		{
			name: "Valid Run",
			input: `package test

type MyType struct {}

func (m *MyType) Foo() {}
`,
			flags: &flags.ParsedFlags{
				PackageName:        "test",
				TypeName:           "MyType",
				PassthroughMethods: map[string]bool{},
			},
			expectedOutput: `package test

// Code generated by MikaÃ«l's proxy generator. DO NOT EDIT.

type MyTypeProxy struct {
	delegate          *MyType
	invocationHandler func(method interface {
		Package() string
		Receiver() string
		Name() string
		Invoke(args []any) []any
	}, args []any) []any
}

type _MyTypeMethod struct {
	methodName string
	receiver   string
	method     func([]any) []any
}

func (m *_MyTypeMethod) Name() string { return m.methodName }

func (m *_MyTypeMethod) Receiver() string { return m.receiver }

func (m *_MyTypeMethod) Package() string { return "test" }

func (m *_MyTypeMethod) Invoke(args []any) []any { return m.method(args) }

func (d *MyTypeProxy) Foo() {

	method := _MyTypeMethod{
		methodName: "Foo",
		receiver:   "*MyType",
		method: func(args []any) []any {
			d.delegate.Foo()
			return []any{}
		},
	}

	var args []any
	d.invocationHandler(&method, args)

}

func NewMyTypeProxy(delegate *MyType, invocationHandler func(method interface {
	Package() string
	Receiver() string
	Name() string
	Invoke(args []any) []any
}, args []any) (retVals []any)) *MyTypeProxy {
	if invocationHandler == nil {
		invocationHandler = func(method interface {
			Package() string
			Receiver() string
			Name() string
			Invoke(args []any) []any
		}, args []any) []any {
			return method.Invoke(args)
		}
	}

	return &MyTypeProxy{
		delegate:          delegate,
		invocationHandler: invocationHandler,
	}
}
`,
			expectedError: nil,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mockFH := &mockFileHandler{data: make(map[string][]byte)}

			// Write the input file.
			mockFH.data["testfile.go"] = []byte(tc.input)

			g, err := new(mockFH, newMockFlags())
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			// Set the package name, type name, and passthrough methods from the test case.
			g.pkg = tc.flags.PackageName
			g.typeName = tc.flags.TypeName
			g.passthroughMethods = tc.flags.PassthroughMethods

			err = g.Run()
			if tc.expectedError == nil && err != nil {
				t.Fatalf("Expected no error, got %v", err)
			} else if tc.expectedError != nil && err == nil {
				t.Fatal("Expected an error, got nil")
			} else if tc.expectedError != nil && err != nil && err.Error() != tc.expectedError.Error() {
				t.Fatalf("Expected error message '%s', got '%s'", tc.expectedError.Error(), err.Error())
			}

			if err == nil {
				generatedFileName := fmt.Sprintf("%s_proxy_gen.go", g.typeName)
				output := string(mockFH.data[generatedFileName])
				if output != tc.expectedOutput {
					t.Errorf("Generated code does not match the expected output.\nExpected:\n%s\nGot:\n%s", tc.expectedOutput, output)
				}
			}
		})
	}
}
