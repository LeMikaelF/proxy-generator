package {{.PackageName}}

// Code generated by MikaÃ«l's proxy generator. DO NOT EDIT.

{{if .Imports}}import ({{range .Imports}}
	"{{.}}"{{end}}
){{end}}

type {{.DecoratorName}} struct {
	original *{{.StructName}}
	advice   func({{.StructName}}MethodInfo, []any, func([]any) []any) []any
}

type {{.StructName}}MethodInfo struct {
	methodName string
    typeName string
}

func (m *{{.StructName}}MethodInfo) MethodName() string {
	return m.methodName
}

{{range .Methods}}
func (d *{{$.DecoratorName}}) {{.Name}}({{.Params}}) {{.Results}} {
	methodInfo := {{$.StructName}}MethodInfo{
		methodName: "{{.Name}}",
        typeName: "{{$.StructName}}",
	};

	var args []any{{- if .Params}} = []any{ {{.ParamNames}} }{{end}}

	proxiedFunc := func(args []any) []any {
		{{- if .Results}}{{range $index, $_ := .ResultTypes}}{{if $index}},{{end}}result{{$index}}{{end}} := {{end}}d.original.{{.Name}}({{.ParamNamesWithTypeAssertions}});
		return []any{ {{- if .Results}}{{range $index, $_ := .ResultTypes}}{{if $index}},{{end}}result{{$index}}{{end}}{{end}}}
	};

	{{- if .Results}}results := d.advice(methodInfo, args, proxiedFunc);
	return {{- range $index, $element := .ResultTypes}}{{if gt $index 0}}, {{end}} results[{{$index}}].({{$element}}){{end}}{{else}}d.advice(methodInfo, args, proxiedFunc){{end}}}
{{end}}





func New{{.DecoratorName}}(delegate *{{.StructName}}, advice func(methodInfo {{.StructName}}MethodInfo, args []any, proxiedFunc func(args []any) (retVal []any)) (retVal []any)) *{{.DecoratorName}} {
	if advice == nil {
		advice = func(info {{.StructName}}MethodInfo, args []any, proxiedFunc func([]any) []any) []any {
			return proxiedFunc(args)
		}
	}

	return &{{.DecoratorName}}{
		original: delegate,
		advice:   advice,
	}
}
