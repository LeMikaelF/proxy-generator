package {{.PackageName}}

// Code generated by MikaÃ«l's proxy generator. DO NOT EDIT.

{{if .Imports}}import ({{range .Imports}}
	"{{.}}"{{end}}
){{end}}

type {{.ProxyName}} struct {
	original *{{.StructName}}
	invocationHandler   func(interface { TypeName() string; Name() string; Invoke(args []any) []any }, []any) []any
}

type {{.StructName}}Method struct {
	methodName string
    typeName string
    method func([]any) []any
}

func (m *{{.StructName}}Method) Name() string {
	return m.methodName
}

func (m *{{.StructName}}Method) TypeName() string {
	return m.typeName
}

func (m *{{.StructName}}Method) Invoke(args []any) []any {
	return m.method(args)
}

{{range .Methods}}
func (d *{{$.ProxyName}}) {{.Name}}({{.Params}}) {{.Results}} {
	Method := {{$.StructName}}Method{
		methodName: "{{.Name}}",
        typeName: "{{$.StructName}}",
	    method: func(args []any) []any {
            {{- if .Results}}{{range $index, $_ := .ResultTypes}}{{if $index}},{{end}}result{{$index}}{{end}} := {{end}}d.original.{{.Name}}({{.ParamNamesWithTypeAssertions}})
            return []any{ {{- if .Results}}{{range $index, $_ := .ResultTypes}}{{if $index}},{{end}}result{{$index}}{{end}}{{end}}}
        },
	};

	var args []any{{- if .Params}} = []any{ {{.ParamNames}} }{{end}};

	{{- if .Results}}results := d.invocationHandler(&Method, args);
	return {{- range $index, $element := .ResultTypes}}{{if gt $index 0}}, {{end}} results[{{$index}}].({{$element}}){{end}}{{else}} d.invocationHandler(&Method, args){{end}}}
{{end}}

func New{{.ProxyName}}(delegate *{{.StructName}}, invocationHandler func(method interface { TypeName() string; Name() string; Invoke(args []any) []any }, args []any) (retVals []any)) *{{.ProxyName}} {
	if invocationHandler == nil {
		invocationHandler = func(method interface { TypeName() string; Name() string; Invoke(args []any) []any }, args []any) []any {
			return method.Invoke(args)
		}
	}

	return &{{.ProxyName}}{
		original: delegate,
		invocationHandler:   invocationHandler,
	}
}
