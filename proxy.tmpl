package {{.PackageName}}

// Code generated by MikaÃ«l's proxy generator. DO NOT EDIT.

{{if .Imports}}import ({{range .Imports}}
	"{{.}}"{{end}}
){{end}}

type {{.ProxyName}} struct {
	original *{{.StructName}}
	advice   func({{.StructName}}MethodInfo, []any) []any
}

type {{.StructName}}MethodInfo struct {
	methodName string
    typeName string
    method func([]any) []any
}

func (m *{{.StructName}}MethodInfo) MethodName() string {
	return m.methodName
}

func (m *{{.StructName}}MethodInfo) TypeName() string {
	return m.typeName
}

func (m *{{.StructName}}MethodInfo) Invoke(args []any) []any {
	return m.method(args)
}

{{range .Methods}}
func (d *{{$.ProxyName}}) {{.Name}}({{.Params}}) {{.Results}} {
	methodInfo := {{$.StructName}}MethodInfo{
		methodName: "{{.Name}}",
        typeName: "{{$.StructName}}",
	    method: func(args []any) []any {
            {{- if .Results}}{{range $index, $_ := .ResultTypes}}{{if $index}},{{end}}result{{$index}}{{end}} := {{end}}d.original.{{.Name}}({{.ParamNamesWithTypeAssertions}})
            return []any{ {{- if .Results}}{{range $index, $_ := .ResultTypes}}{{if $index}},{{end}}result{{$index}}{{end}}{{end}}}
        },
	};

	var args []any{{- if .Params}} = []any{ {{.ParamNames}} }{{end}};

	{{- if .Results}}results := d.advice(methodInfo, args);
	return {{- range $index, $element := .ResultTypes}}{{if gt $index 0}}, {{end}} results[{{$index}}].({{$element}}){{end}}{{else}} d.advice(methodInfo, args){{end}}}
{{end}}

func New{{.ProxyName}}(delegate *{{.StructName}}, advice func(method {{.StructName}}MethodInfo, args []any) (retVals []any)) *{{.ProxyName}} {
	if advice == nil {
		advice = func(method {{.StructName}}MethodInfo, args []any) []any {
			return method.Invoke(args)
		}
	}

	return &{{.ProxyName}}{
		original: delegate,
		advice:   advice,
	}
}
